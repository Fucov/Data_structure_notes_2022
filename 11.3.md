<center>11.3课程</center>

[TOC]



# 1.贪心算法

- ```python
  #楼梯问题递归----斐波那契数列
  def fun(n):
      if n==1:
          return 1
      elif n==2:
          return 2
      else:
          return fun(n-1)+fun(n-2)
  
  print(fun(10))
  ```

- ```python
  #找零问题
  '''超市的自动柜员机（POS机）要找给顾客钞票张数最少的现金。假设有面值为1元、3元和5元的钞票若干枚，问：如何用最少的钞票凑够11元找零？'''
  #方法一 遍历全部组合，找到最少
  #方法二 贪心算法，每一步找最大面值
  sum=0
  change_dict={}
  money=int(input('money:'))
  list_coin=list(map(int, input('coin:').split()))
  list_coin.sort() #从小到大
  
  for i in list_coin[::-1]:
      change_dict[i]=money//i
      sum+=money//i
      money%=i
      if money<list_coin[0]:
          break
  if money !=0:
      print('无法找零')
  else:
      print(sum,change_dict)
      
  ```

> 贪心算法只能取当前最优（局部最优），最后要判断是否是真正全局最优解。
>
> 可以相对快速获得可行解，
>
> 比如某国的钱币分为  1元3元4元 ，如果要拿6元钱  怎么拿？贪心的话  先拿4  再拿两个1 元，一共3张钱 。实际最优呢？  两张3元就够了  

# 2.动态规划

- 找零问题

  > ***贪心算法***几乎只考虑了局部最优，因此无法应对需要考虑整体最优的算法问题。
  >
  > 用***递归***的方法来穷举出所有可能的组合，从这些可能组合中找出最优解。虽然递归考虑了整体最优，而且真的可以解决问题，但效率太低。
  >
  > 因此，为了解决低效问题，我们又提出了***递归备忘录***的概念。你应该发现了，我们在解决硬币找零问题时的思路是一以贯之的：发现问题，找解决方案；如果方案有局限性，那么就看如何扩展视野，找寻更优的方法。

  

- 0/1背包问题

  - 枚举，用二进制（0001，0010，0011，0100……），遍历所有子集，若重量合适，且价值大于已选目标最大，则替换为新的目标组合
  - 动态规划，

